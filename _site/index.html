<!DOCTYPE html>
<html>

  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <title>Lct</title>
    <meta name="description" content="">

    <link rel="shortcut icon" href="/favicon.ico?" type="image/x-icon">
    <link rel="icon" href="/favicon.ico?" type="image/x-icon">
    <link rel="stylesheet" href=" /css/fontawesome/css/font-awesome.min.css ">
    <link rel="stylesheet" href=" /css/main.css ">
    <link rel="canonical" href="http://localhost:4000/">
    <link rel="alternate" type="application/rss+xml" title="Lct" href="http://localhost:4000 /feed.xml ">



</head>


  <body>

    <header id="top">
    <div class="wrapper">
        <a href="/" class="brand">Lct</a>
        <small>Software Dev Engineer</small>
        <button id="headerMenu" class="menu"><i class="fa fa-bars"></i></button>
        <nav id="headerNav">
            <ul>
                <li>
                    
                    <a class="active" href="/">
                        
                        <i class="fa fa-home"></i>Home
                    </a>
                </li>

                
                    
                    <li>
                        
                        <a href="/archive/">
                        
                            <i class="fa fa-archive"></i>Archives
                        </a>
                    </li>
                    
                
                    
                    <li>
                        
                        <a href="/category/">
                        
                            <i class="fa fa-th-list"></i>Categories
                        </a>
                    </li>
                    
                
                    
                    <li>
                        
                        <a href="/about/">
                        
                            <i class="fa fa-heart"></i>About
                        </a>
                    </li>
                    
                
                    
                
                    
                
                    
                
            </ul>
        </nav>
    </div>
</header>


        <div class="page clearfix" index>
    <div class="left">
        <h1>Welcome to Lct's Blog!</h1>
        <small>这里记录着我的软件学习之路</small>
        <hr>
        <ul>
            
              <li>
                <h2>
                  <a class="post-link" href="/2017/09/22/javascritp_closure/">Javascript closure</a>
                </h2>
                <div class="label">
                    <div class="label-card">
                        <i class="fa fa-calendar"></i>2017-09-22
                    </div>
                    <div class="label-card">
                        
                    </div>
                    <div class="label-card">
                        
                    </div>

                    <div class="label-card">
                    


<!-- <span class="point">•</span> -->
<span class="categories">
  <i class="fa fa-th-list"></i>
  
    
        <a href="/category/#javascript" title="Category: javascript" rel="category">javascript</a>
    
  

  <!-- <span class="point">•</span> -->
</span>


                    </div>

                    <div class="label-card">
                    
<!-- <span class="point">•</span> -->
<span class="pageTag">
  <i class="fa fa-tags"></i>
  
    
  

</span>

                    </div>
                </div>
                <div class="excerpt">
                    <h1 id="closure">Closure</h1>
<p>Javascript是面向函数的语言，其本身非常灵活。函数创建以后，可以复制给变量或者作为参数传递给另一个函数，并在其他地方被调用。通常，一个函数可以访问函数外部的变量。而且这种访问很常见。但是，如果外部变量被改变，函数获得的是变量的初始值还是变量的最新值？另外，当函数被传递到另外一个地方并被调用，它是否还能访问之前的外部变量？下面我们讨论Javascript中的例子。（本文在’use strict;’条件下）</p>

<h2 id="投石问路">投石问路</h2>
<p>首先我们提出两个问题引出对内部机制由浅入深的分析。
1、函数sayHi访问外部变量name，下面让我们看一下变量的值变化：</p>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">let</span> <span class="nx">name</span> <span class="o">=</span> <span class="s2">"John"</span><span class="p">;</span>

<span class="kd">function</span> <span class="nx">sayHi</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">alert</span><span class="p">(</span><span class="s2">"Hi, "</span> <span class="o">+</span> <span class="nx">name</span><span class="p">);</span>
<span class="p">}</span>

<span class="nx">name</span> <span class="o">=</span> <span class="s2">"Pete"</span><span class="p">;</span>

<span class="nx">sayHi</span><span class="p">();</span> <span class="c1">// what will it show: "John" or "Pete"?</span></code></pre></figure>

<p>问题：sayHi函数使用的是变量最新的值吗？</p>

<p>2、函数makeWoker范围一个新的函数。返回的新函数可以在其他地方被调用。那么，当该函数被调用的时候，它是在创建的上下文访问变量，还是在被调用的上下文访问变量？</p>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">function</span> <span class="nx">makeWorker</span><span class="p">()</span> <span class="p">{</span>
  <span class="kd">let</span> <span class="nx">name</span> <span class="o">=</span> <span class="s2">"Pete"</span><span class="p">;</span>

  <span class="k">return</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">alert</span><span class="p">(</span><span class="nx">name</span><span class="p">);</span>
  <span class="p">};</span>
<span class="p">}</span>

<span class="kd">let</span> <span class="nx">name</span> <span class="o">=</span> <span class="s2">"John"</span><span class="p">;</span>

<span class="c1">// create a function</span>
<span class="kd">let</span> <span class="nx">work</span> <span class="o">=</span> <span class="nx">makeWorker</span><span class="p">();</span>

<span class="c1">// call it</span>
<span class="nx">work</span><span class="p">();</span> <span class="c1">// what will it show? "Pete" (name where created) or "John" (name where called)?</span></code></pre></figure>

<h2 id="词法上下文">词法上下文</h2>
<p>探究函数与变量的问题，需要先明确什么是“变量”，或者说“变量的机制”是什么。
在Javascript中，运行中的函数、代码块和脚本作为整体拥有一个对应的对象：Lexical Environment，以下简写为LE。
Lexical Environment由两部分组成：</p>

<p>1、Environment Record：具有所有当前范围内变量作为其属性的对象（以及某些其他信息，如this的值），以下简写ER。</p>

<p>2、对外部lexical environment的引用，通常是紧接着的上级代码块（包围着当前代码的代码部分）。</p>

<p>因此，“变量”就是特别的内部对象（ER）的一个属性。“读写变量的值”即是“读写该对象的属性”。
例如，下面的代码中包含一个LE：</p>

<p><img src="https://javascript.info/article/closure/lexical-environment-global@2x.png" alt="Lexical Environment" /></p>

<p>这是便是全局LE，与整个脚本相关联。对于浏览器，所有&lt;script&gt;标签共享相同的LE。</p>

<p>在上图中，矩形表示ER（变量存储），箭头表示外部引用。全局LE没有外部环境，所以就是null。</p>

<p>以下是let变量工作原理的更大图景：</p>

<p><img src="https://javascript.info/article/closure/lexical-environment-global-2@2x.png" alt="Lexical Environment" /></p>

<p>右侧的矩形演示了执行期间全局LE如何变化：</p>

<p>1、脚本启动时，词法环境为空。</p>

<p>2、在let phrase出现的定义。现在它最初没有值，所以undefined存储。</p>

<p>3、phrase 被分配。</p>

<p>4、phrase 指新值。</p>

<p>一切看起来都很简单，对吧？</p>

<p>总结：</p>

<ul>
  <li>变量是与当前执行的块/函数/脚本相关联的特殊内部对象的属性。</li>
  <li>使用变量实际上是使用该对象的属性。</li>
</ul>

<h2 id="函数声明">函数声明</h2>
<p>函数声明是特殊的。与let声明函数不同，当创建LE时函数代码被处理，而不是在执行到代码的时候。对于全局LE，这意味着脚本启动的时刻。</p>

<p>…这就是为什么我们可以在定义之前调用函数声明。</p>

<p>下面的代码举例，LE从一开始就不是空的。它包含say，因为say是一个函数声明。后来let声明得到phrase：</p>

<p><img src="https://javascript.info/article/closure/lexical-environment-global-3@2x.png" alt="Lexical Environment" /></p>

<h2 id="内外词汇环境">内外词汇环境</h2>
<p>在调用say()的时候使用外部变量，所以让我们看看发生了什么细节。</p>

<p>首先，当一个函数运行时，会自动创建一个新的函数LE。这是所有函数的一般规则。该LE用于存储本地变量和调用的参数。</p>

<p>当执行到say(“John”)内部的LE图片，标有三角箭头的行：</p>

<p><img src="https://javascript.info/article/closure/lexical-environment-simple@2x.png" alt="Lexical Environment" /></p>

<p>在函数调用期间，我们有两个LE：内部函数（用于函数调用）和外部函数（全局函数）：</p>

<ul>
  <li>内部LE对应于当前的执行say。它有一个变量：name函数参数。我们调用say(“John”)，所以name的值是”John”。外部LE是全局LE。</li>
  <li>内部LE会引用外部LE。</li>
</ul>

<p>当代码想要访问变量时，它首先在内部LE中搜索，然后在外部LE中搜索，然后在更外部LE中搜索，直到最外部LE。</p>

<p>如果在任何地方找不到变量，那就是严格模式（’use strict’;）下的错误。如果不是严格模式，对未定义变量的赋值创建一个新的全局变量，以便向后兼容。</p>

<p>我们来看看我们的例子中搜索如何进行：</p>

<ul>
  <li>当say内部的alert想要访问时name，它会立即在函数LE中找到它。</li>
  <li>当它想要访问时phrase，那么没有phrase本地的，所以它遵循向外搜索引用并在全局LE找到它。</li>
</ul>

<p><img src="https://javascript.info/article/closure/lexical-environment-simple-lookup@2x.png" alt="Lexical Environment" /></p>

<p>现在我们可以从本章开始就给出第一块砖的答案。</p>

<p>一个函数得到现在的外部变量，最近的值。</p>

<p>这是因为所描述的机制。旧的变量值不保存在任何地方。当一个函数想要它们时，它需要来自它自己或者外部词汇环境的当前值。</p>

<p>所以第一个问题的答案是 Pete：</p>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">let</span> <span class="nx">name</span> <span class="o">=</span> <span class="s2">"John"</span><span class="p">;</span>

<span class="kd">function</span> <span class="nx">sayHi</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">alert</span><span class="p">(</span><span class="s2">"Hi, "</span> <span class="o">+</span> <span class="nx">name</span><span class="p">);</span>
<span class="p">}</span>

<span class="nx">name</span> <span class="o">=</span> <span class="s2">"Pete"</span><span class="p">;</span> <span class="c1">// (*)</span>

<span class="nx">sayHi</span><span class="p">();</span> <span class="c1">// Pete</span></code></pre></figure>

<p>以上代码的执行流程：</p>

<p>1、全局LE有属性name: “John”。
2、在行(*)全局LE被改变了name: “Pete”。
3、当该函数say()被执行并且name从外部获取时。这是来自全局LE “Pete”。</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>一个函数 - 一个词汇环境
请注意，每次函数运行时都会创建一个新的功能词汇环境。

而且如果一个函数被多次调用，那么每个调用都将有自己的词汇环境，其特定的局部变量和参数非常适用。
</code></pre></div></div>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>词汇环境是一个规范对象
“词汇环境”是一个规范对象。我们无法在我们的代码中获取此对象，并直接操作它。JavaScript引擎还可以对其进行优化，丢弃未使用的变量来节省内存并执行其他内部技巧，但可见行为应如所述。
</code></pre></div></div>

<h2 id="嵌套函数">嵌套函数</h2>
<p>一个函数在另一个函数内创建时被称为“嵌套”。</p>

<p>从技术上讲，这很容易实现。</p>

<p>我们可以使用它来组织代码，如下所示：</p>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">function</span> <span class="nx">sayHiBye</span><span class="p">(</span><span class="nx">firstName</span><span class="p">,</span> <span class="nx">lastName</span><span class="p">)</span> <span class="p">{</span>

  <span class="c1">// helper nested function to use below</span>
  <span class="kd">function</span> <span class="nx">getFullName</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">firstName</span> <span class="o">+</span> <span class="s2">" "</span> <span class="o">+</span> <span class="nx">lastName</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="nx">alert</span><span class="p">(</span> <span class="s2">"Hello, "</span> <span class="o">+</span> <span class="nx">getFullName</span><span class="p">()</span> <span class="p">);</span>
  <span class="nx">alert</span><span class="p">(</span> <span class="s2">"Bye, "</span> <span class="o">+</span> <span class="nx">getFullName</span><span class="p">()</span> <span class="p">);</span>

<span class="p">}</span></code></pre></figure>

<p>这里嵌套函数getFullName()是为了方便创建。它可以访问外部变量，因此可以返回全名。</p>

<p>更有趣的是，可以返回嵌套函数：作为新对象的属性（如果外部函数创建具有函数属性的对象）或嵌套函数自身。然后在别的地方使用。无论在哪里，它仍然保持访问相同的外部变量。</p>

<p>构造函数的一个例子（参见构造函数，运算符“new”一章）：</p>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="c1">// constructor function returns a new object</span>
<span class="kd">function</span> <span class="nx">User</span><span class="p">(</span><span class="nx">name</span><span class="p">)</span> <span class="p">{</span>

  <span class="c1">// the object method is created as a nested function</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">sayHi</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">alert</span><span class="p">(</span><span class="nx">name</span><span class="p">);</span>
  <span class="p">};</span>
<span class="p">}</span>

<span class="kd">let</span> <span class="nx">user</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">User</span><span class="p">(</span><span class="s2">"John"</span><span class="p">);</span>
<span class="nx">user</span><span class="p">.</span><span class="nx">sayHi</span><span class="p">();</span> <span class="c1">// the method code has access to the outer "name"</span></code></pre></figure>

<p>返回函数的示例：</p>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">function</span> <span class="nx">makeCounter</span><span class="p">()</span> <span class="p">{</span>
  <span class="kd">let</span> <span class="nx">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

  <span class="k">return</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">count</span><span class="o">++</span><span class="p">;</span> <span class="c1">// has access to the outer counter</span>
  <span class="p">};</span>
<span class="p">}</span>

<span class="kd">let</span> <span class="nx">counter</span> <span class="o">=</span> <span class="nx">makeCounter</span><span class="p">();</span>

<span class="nx">alert</span><span class="p">(</span> <span class="nx">counter</span><span class="p">()</span> <span class="p">);</span> <span class="c1">// 0</span>
<span class="nx">alert</span><span class="p">(</span> <span class="nx">counter</span><span class="p">()</span> <span class="p">);</span> <span class="c1">// 1</span>
<span class="nx">alert</span><span class="p">(</span> <span class="nx">counter</span><span class="p">()</span> <span class="p">);</span> <span class="c1">// 2</span></code></pre></figure>

<p>我们来看一下这个makeCounter例子。它创建“counter”函数，每次调用返回下一个数字。尽管是简单，该代码的稍微修改的变体具有实际用途，例如，作为伪随机数生成器等。所以这个例子不是很随意的。</p>

<p>counter内部如何工作？</p>

<p>当内部函数运行时，count++从内向外搜索变量。对于上面的示例，顺序将是：</p>

<p><img src="https://javascript.info/article/closure/lexical-search-order@2x.png" alt="Lexical Environment" /></p>

<p>1、嵌套函数的内部变量。</p>

<p>2、外部函数的变量。</p>

<p>3、…更外部直到全局变量。</p>

<p>在该示例count中，在步骤中找到2。当一个外部变量被修改时，它在被找到的位置被改变。所以count++找到外部变量，并在它所属的LE中增加它。就像我们执行力let count = 1。</p>

<p>这里有两个问题：</p>

<p>1、我们可以从不属于的代码makeCounter的地方重置counter吗？例如alert调用之后的地方。
2、如果我们makeCounter()多次调用——它返回很多counter函数。他们是独立的还是共享count？</p>

<p>尝试在阅读前回答他们。</p>

<p>…你做完了吗？</p>

<p>好的，我们一起去解答。</p>

<p>1、不可能。这counter是一个局部函数变量，我们无法从外部访问它。
2、对于每一次调用makeCounter()会创建新的LE，拥有独立的counter。所以counter函数是独立的。
这是演示：</p>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">function</span> <span class="nx">makeCounter</span><span class="p">()</span> <span class="p">{</span>
  <span class="kd">let</span> <span class="nx">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">return</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">count</span><span class="o">++</span><span class="p">;</span>
  <span class="p">};</span>
<span class="p">}</span>

<span class="kd">let</span> <span class="nx">counter1</span> <span class="o">=</span> <span class="nx">makeCounter</span><span class="p">();</span>
<span class="kd">let</span> <span class="nx">counter2</span> <span class="o">=</span> <span class="nx">makeCounter</span><span class="p">();</span>

<span class="nx">alert</span><span class="p">(</span> <span class="nx">counter1</span><span class="p">()</span> <span class="p">);</span> <span class="c1">// 0</span>
<span class="nx">alert</span><span class="p">(</span> <span class="nx">counter1</span><span class="p">()</span> <span class="p">);</span> <span class="c1">// 1</span>

<span class="nx">alert</span><span class="p">(</span> <span class="nx">counter2</span><span class="p">()</span> <span class="p">);</span> <span class="c1">// 0 (independant)</span></code></pre></figure>

<h2 id="环境详解">环境详解</h2>
<p>现在，您了解闭包是如何工作的，我们终于可以坚持下去了。</p>

<p>以下是makeCounter示例一步一步分析，以确保了解所有内容。请注意[[Environment]]我们尚未深究。</p>

<p>1、脚本刚刚开始，只有全局LE：</p>

<p><img src="https://javascript.info/article/closure/lexenv-nested-makecounter-1@2x.png" alt="Lexical Environment" /></p>

<p>在起始时刻只有makeCounter函数，因为它是一个函数声明。它还没有运行</p>

<p>所有函数“诞生时”都有一个隐藏[[Environment]]属性并且指向创建者。我们还没有深究它，但从技术上讲，这个函数知道它在哪里被创建的。</p>

<p>在这里，makeCounter是在全局LE中创建的，所以[[Environment]]保持引用它。</p>

<p>换句话说，一个函数有“印记”，记录其被创建所处的LE。[[Environment]]包含这个“印记”。</p>

<p>2、然后代码运行，makeCounter()执行调用。这是执行makeCounter()里面第一行的时刻的图片：</p>

<p><img src="https://javascript.info/article/closure/lexenv-nested-makecounter-2@2x.png" alt="Lexical Environment" /></p>

<p>在调用时，makeCounter()创建了词汇环境，以保存其变量和参数。</p>

<p>作为LE，它存储两部分：</p>

<p>1、记录局部变量的LE。在现在的情况下count是唯一的局部变量（当执行let count时）。</p>

<p>2、外部LE引用，在函数的[[Environment]]里设置。这里makeCounter的[[Environment]]引用全局LE。</p>

<p>所以现在我们有两个LE：第一个是全局的，第二个是当前makeCounter的并外部引用全局LE。</p>

<p>3、在执行期间makeCounter()，创建一个小的嵌套函数。</p>

<p>使用函数声明或函数表达式创建函数无关紧要。所有函数的[[Environment]]都引用它们所在的LE。所以新的小的嵌套函数也得到它。</p>

<p>对于我们新的嵌套函数，它的[[Environment]]值是当前makeCounter()的LE：</p>

<p><img src="https://javascript.info/article/closure/lexenv-nested-makecounter-3@2x.png" alt="Lexical Environment" /></p>

<p>请注意，在此步骤中，内部函数已创建，但尚未调用。内部的代码function() { return count++; }没有运行，我们将返回它。</p>

<p>4、随着执行继续，调用makeCounter()结束，并将结果（小嵌套函数）赋值给全局变量counter：</p>

<p><img src="https://javascript.info/article/closure/lexenv-nested-makecounter-4@2x.png" alt="Lexical Environment" /></p>

<p>该函数只有一行：return count++，当我们调用它将被执行。</p>

<p>5、当counter()被调用时，为其创建一个“空”LE。它本身没有局部变量。但counter的[[Environment]]被用作它的外部引用，所以它可以访问makeCounter()的变量：</p>

<p><img src="https://javascript.info/article/closure/lexenv-nested-makecounter-5@2x.png" alt="Lexical Environment" /></p>

<p>现在，如果它访问变量，它首先搜索自己的LE（空），然后搜索前一个makeCounter()调用的LE，然后是全局的。</p>

<p>在最近的外部LE中寻找count，它会在makeCounter的LE中找到。</p>

<p>请注意内存管理在这里工作。当makeCounter()调用结束后，一段时间内，它的LE被保留在内存中，因为有一个嵌套函数的[[Environment]]引用它。</p>

<p>一般来说，LE对象只要存在可以使用它的函数就可以生存。</p>

<p>6、调用counter()不仅返回值count，还可以增加它的值。请注意，修改已完成“到位”。count在被发现的环境中正确地修改了该值。</p>

<p><img src="https://javascript.info/article/closure/lexenv-nested-makecounter-6@2x.png" alt="Lexical Environment" /></p>

<p>所以我们回到上一步，唯一的改变 - 新的count值。</p>

<p>7、下一次counter()调用也是一样的。</p>

<p>本章开头的第二块砖的答案现在应该是显而易见的。</p>

<p>work()通过外部LE获取name：</p>

<p><img src="https://javascript.info/article/closure/lexenv-nested-work@2x.png" alt="Lexical Environment" /></p>

<p>所以结果就是”Pete”。</p>

<p>……但是，如果在makeWorker()中没有let name，那么搜索会到外面去，并采用全局变量，那就是”John”。</p>

<p>闭包：
有一个通用的编程术语“闭包”，开发人员通常应该知道。</p>

<p>一个闭包是，记住它的外部变量，可以访问它们的函数。在某些语言中，这是不可能的，或者应该以特殊的方式写成，以使其发生。但是如上所述，在JavaScript中，所有函数都是自然闭包（只有一个排除，在“new”语法中被覆盖）。</p>

<p>也就是说：它们会用[[Environment]]属性自动记住创建的位置，并且所有这些都可以访问外部变量。</p>

<p>在接受采访时，前端开发人员提出了一个关于“什么是闭包”的问题，一个有效的答案将是，JavaScript中所有函数都是闭包，也可提及更多技术细节关于[[Environment]]属性以及LE如何工作。</p>

<h2 id="代码块和循环iife">代码块和循环，IIFE</h2>
<p>上面的例子集中在函数上。但LE也存在于代码块{…}中。</p>

<p>它们是在代码块运行时创建的，并且包含块局部变量。这里有几个例子。</p>

<h3 id="if">if</h3>
<p>在下面的示例中，当执行进入if块时，将为其创建新的“if-only” LE：</p>

<p><img src="https://javascript.info/article/closure/lexenv-if@2x.png" alt="Lexical Environment" /></p>

<p>新的LE获得闭包的外部引用，所以phrase可以找到。但是内部声明的所有变量和函数表达式都存在于if的LE中，不能从外部访问。</p>

<p>例如，在if完成后，alert下面将不能访问user，因此错误。</p>

<h3 id="forwhile">for，while</h3>
<p>对于一个循环，每个运行都有一个单独的LE。如果变量被声明for，那么它也是该LE的局部变量：</p>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="k">for</span><span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// Each loop has its own Lexical Environment</span>
  <span class="c1">// {i: value}</span>
<span class="p">}</span>

<span class="nx">alert</span><span class="p">(</span><span class="nx">i</span><span class="p">);</span> <span class="c1">// Error, no such variable</span></code></pre></figure>

<p>这实际上是一个例外，因为let i看起来在{…}之外。但事实上，每个循环的运行都有自己的LE包含当前i的值。</p>

<p>循环后，i不可见。</p>

<h3 id="代码块">代码块</h3>
<p>我们还可以使用“裸”代码块{…}将变量隔离为“局部范围”。</p>

<p>例如，在Web浏览器中，所有脚本共享相同的全局区域。因此，如果我们在一个脚本中创建一个全局变量，它将变得可供其他人使用。但是，如果两个脚本使用相同的变量名称并相互覆盖，则会成为冲突的根源。</p>

<p>如果变量名是一个广泛的词，那么脚本作者就不会相互察觉。</p>

<p>如果我们想回避，我们可以使用代码块来隔离整个脚本或其中的一个区域：</p>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="p">{</span>
  <span class="c1">// do some job with local variables that should not be seen outside</span>

  <span class="kd">let</span> <span class="nx">message</span> <span class="o">=</span> <span class="s2">"Hello"</span><span class="p">;</span>

  <span class="nx">alert</span><span class="p">(</span><span class="nx">message</span><span class="p">);</span> <span class="c1">// Hello</span>
<span class="p">}</span>

<span class="nx">alert</span><span class="p">(</span><span class="nx">message</span><span class="p">);</span> <span class="c1">// Error: message is not defined</span></code></pre></figure>

<p>块之外的代码（或另一个脚本中的代码）不会看到变量，因为代码块具有自己的词汇环境。</p>

<h3 id="iife">IIFE</h3>
<p>在旧的脚本中，可以找到用于此目的的所谓的“立即调用的函数表达式”（缩写为IIFE）。</p>

<p>他们看起来像这样：</p>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span>

  <span class="kd">let</span> <span class="nx">message</span> <span class="o">=</span> <span class="s2">"Hello"</span><span class="p">;</span>

  <span class="nx">alert</span><span class="p">(</span><span class="nx">message</span><span class="p">);</span> <span class="c1">// Hello</span>

<span class="p">})();</span></code></pre></figure>

<p>这里创建一个函数表达式并立即调用。所以代码现在执行，并有自己的私有变量。</p>

<p>函数表达式用括号括起来(function {…})，因为当JavaScript在解析到”function”在时，它将其解释为函数声明的开始。但是函数声明必须有一个名称，所以会出现一个错误：</p>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="c1">// Error: Unexpected token (</span>
<span class="kd">function</span><span class="p">()</span> <span class="p">{</span> <span class="c1">// &lt;-- JavaScript cannot find function name, meets ( and gives error</span>

  <span class="kd">let</span> <span class="nx">message</span> <span class="o">=</span> <span class="s2">"Hello"</span><span class="p">;</span>

  <span class="nx">alert</span><span class="p">(</span><span class="nx">message</span><span class="p">);</span> <span class="c1">// Hello</span>

<span class="p">}();</span></code></pre></figure>

<p>我们可以说“好吧，让它成为功能声明，让我们添加一个名字”，但它不会奏效。JavaScript不允许立即调用函数声明：</p>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="c1">// syntax error because of brackets below</span>
<span class="kd">function</span> <span class="nx">go</span><span class="p">()</span> <span class="p">{</span>

<span class="p">}();</span> <span class="c1">// &lt;-- can't call Function Declaration immediately</span></code></pre></figure>

<p>因此，需要括号才能表明，该函数是在另一个表达式的上下文中创建的，因此它是一个Function Expression。不需要名字，可以立即调用。</p>

<p>还有其他方式告诉JavaScript我们的函数是函数表达式：</p>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="c1">// Ways to create IIFE</span>

<span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">alert</span><span class="p">(</span><span class="s2">"Brackets around the function"</span><span class="p">);</span>
<span class="p">})();</span>

<span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">alert</span><span class="p">(</span><span class="s2">"Brackets around the whole thing"</span><span class="p">);</span>
<span class="p">}());</span>

<span class="o">!</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">alert</span><span class="p">(</span><span class="s2">"Bitwise NOT operator starts the expression"</span><span class="p">);</span>
<span class="p">}();</span>

<span class="o">+</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">alert</span><span class="p">(</span><span class="s2">"Unary plus starts the expression"</span><span class="p">);</span>
<span class="p">}();</span></code></pre></figure>

<p>在上面的所有情况下，我们声明函数表达式并立即运行。</p>

<h3 id="垃圾回收">垃圾回收</h3>
<p>我们一直在讨论的LE对象是与常规值相同的内存管理规则。</p>

<ul>
  <li>通常函数运行后，LE被清理。例如：</li>
</ul>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">function</span> <span class="nx">f</span><span class="p">()</span> <span class="p">{</span>
  <span class="kd">let</span> <span class="nx">value1</span> <span class="o">=</span> <span class="mi">123</span><span class="p">;</span>
  <span class="kd">let</span> <span class="nx">value2</span> <span class="o">=</span> <span class="mi">456</span><span class="p">;</span>
<span class="p">}</span>

<span class="nx">f</span><span class="p">();</span></code></pre></figure>

<p>这里的两个值在技术上是LE的属性。但是，在f()完成LE变得无法访问之后，它就从内存中删除。</p>

<ul>
  <li>…但是如果有一个嵌套函数在结束之后仍然可以访问f，那么它的[[Environment]]引用也保持外部词汇环境的存在：</li>
</ul>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">function</span> <span class="nx">f</span><span class="p">()</span> <span class="p">{</span>
  <span class="kd">let</span> <span class="nx">value</span> <span class="o">=</span> <span class="mi">123</span><span class="p">;</span>

  <span class="kd">function</span> <span class="nx">g</span><span class="p">()</span> <span class="p">{</span> <span class="nx">alert</span><span class="p">(</span><span class="nx">value</span><span class="p">);</span> <span class="p">}</span>

  <span class="k">return</span> <span class="nx">g</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">let</span> <span class="nx">g</span> <span class="o">=</span> <span class="nx">f</span><span class="p">();</span> <span class="c1">// g is reachable, and keeps the outer lexical environment in memory</span></code></pre></figure>

<ul>
  <li>请注意，如果f()被多次调用，并且生成的函数被保存，则相应的LE对象也将保留在内存中。所有3个在下面的代码中：</li>
</ul>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">function</span> <span class="nx">f</span><span class="p">()</span> <span class="p">{</span>
  <span class="kd">let</span> <span class="nx">value</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">random</span><span class="p">();</span>

  <span class="k">return</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span> <span class="nx">alert</span><span class="p">(</span><span class="nx">value</span><span class="p">);</span> <span class="p">};</span>
<span class="p">}</span>

<span class="c1">// 3 functions in array, every of them links to Lexical Environment</span>
<span class="c1">// from the corresponding f() run</span>
<span class="c1">//         LE   LE   LE</span>
<span class="kd">let</span> <span class="nx">arr</span> <span class="o">=</span> <span class="p">[</span><span class="nx">f</span><span class="p">(),</span> <span class="nx">f</span><span class="p">(),</span> <span class="nx">f</span><span class="p">()];</span></code></pre></figure>

<ul>
  <li>LE对象在无法访问时销毁。也就是说：当没有引用它的嵌套函数时。在下面的代码中，在g变得无法访问之后，value也从内存中清除;</li>
</ul>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">function</span> <span class="nx">f</span><span class="p">()</span> <span class="p">{</span>
  <span class="kd">let</span> <span class="nx">value</span> <span class="o">=</span> <span class="mi">123</span><span class="p">;</span>

  <span class="kd">function</span> <span class="nx">g</span><span class="p">()</span> <span class="p">{</span> <span class="nx">alert</span><span class="p">(</span><span class="nx">value</span><span class="p">);</span> <span class="p">}</span>

  <span class="k">return</span> <span class="nx">g</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">let</span> <span class="nx">g</span> <span class="o">=</span> <span class="nx">f</span><span class="p">();</span> <span class="c1">// while g is alive</span>
<span class="c1">// there corresponding Lexical Environment lives</span>

<span class="nx">g</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span> <span class="c1">// ...and now the memory is cleaned up</span></code></pre></figure>

<h3 id="现实优化">现实优化</h3>
<p>正如我们所看到的，在理论上，当函数存在时，所有外部变量也被保留。</p>

<p>但实际上，JavaScript引擎尝试优化。他们分析变量使用情况，如果很容易看到外部变量不被使用 - 它被删除。</p>

<p>V8（Chrome，Opera）中的一个重要副作用就是调试时变量不可用。</p>

<p>尝试使用Chrome中的开放式开发工具运行下面的示例。</p>

<p>当它暂停时，在控制台输入alert(value)。</p>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">function</span> <span class="nx">f</span><span class="p">()</span> <span class="p">{</span>
  <span class="kd">let</span> <span class="nx">value</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">random</span><span class="p">();</span>

  <span class="kd">function</span> <span class="nx">g</span><span class="p">()</span> <span class="p">{</span>
    <span class="kr">debugger</span><span class="p">;</span> <span class="c1">// in console: type alert( value ); No such variable!</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="nx">g</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">let</span> <span class="nx">g</span> <span class="o">=</span> <span class="nx">f</span><span class="p">();</span>
<span class="nx">g</span><span class="p">();</span></code></pre></figure>

<p>你可以看到 - 没有这样的变量！理论上应该是可以访问的，但引擎优化了它。</p>

<p>这可能导致有趣的（如果不是这么耗时的）调试问题。其中一个 - 我们可以看到一个相同命名的外部变量，而不是预期的外部变量：</p>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">let</span> <span class="nx">value</span> <span class="o">=</span> <span class="s2">"Surprise!"</span><span class="p">;</span>

<span class="kd">function</span> <span class="nx">f</span><span class="p">()</span> <span class="p">{</span>
  <span class="kd">let</span> <span class="nx">value</span> <span class="o">=</span> <span class="s2">"the closest value"</span><span class="p">;</span>

  <span class="kd">function</span> <span class="nx">g</span><span class="p">()</span> <span class="p">{</span>
    <span class="kr">debugger</span><span class="p">;</span> <span class="c1">// in console: type alert( value ); Surprise!</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="nx">g</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">let</span> <span class="nx">g</span> <span class="o">=</span> <span class="nx">f</span><span class="p">();</span>
<span class="nx">g</span><span class="p">();</span></code></pre></figure>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>提示！
V8的这个功能很有用。如果您正在使用Chrome / Opera进行调试，迟早会遇到它。

这不是调试器的错误，而是V8的一个特殊功能。也许会有一段时间改变。您总是可以通过在此页面上运行示例来检查它。
</code></pre></div></div>

<p>Check out the <a href="https://javascript.info/closure">Javascript Closure</a>.</p>


                </div>
                <div class="read-all">
                    <a  href="/2017/09/22/javascritp_closure/"><i class="fa fa-newspaper-o"></i>Read All</a>
                </div>
                <hr>
              </li>
            
              <li>
                <h2>
                  <a class="post-link" href="/2017/09/20/leetcode_alg_2/">Leetcode: 2. Add Two Numbers</a>
                </h2>
                <div class="label">
                    <div class="label-card">
                        <i class="fa fa-calendar"></i>2017-09-20
                    </div>
                    <div class="label-card">
                        
                    </div>
                    <div class="label-card">
                        
                    </div>

                    <div class="label-card">
                    


<!-- <span class="point">•</span> -->
<span class="categories">
  <i class="fa fa-th-list"></i>
  
    
        <a href="/category/#leetcode" title="Category: leetcode" rel="category">leetcode</a>&nbsp;
    
        <a href="/category/#algorithm" title="Category: algorithm" rel="category">algorithm</a>
    
  

  <!-- <span class="point">•</span> -->
</span>


                    </div>

                    <div class="label-card">
                    
<!-- <span class="point">•</span> -->
<span class="pageTag">
  <i class="fa fa-tags"></i>
  
    
  

</span>

                    </div>
                </div>
                <div class="excerpt">
                    <h1 id="problem">Problem</h1>
<p>You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.</p>

<p>You may assume the two numbers do not contain any leading zero, except the number 0 itself.</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)
Output: 7 -&gt; 0 -&gt; 8
</code></pre></div></div>

<h1 id="solution">Solution</h1>

<p>The approach is simple. Loop through each pair from two linked list, add and check if carray</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="cm">/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */</span>
<span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">ListNode</span><span class="o">*</span> <span class="n">addTwoNumbers</span><span class="p">(</span><span class="n">ListNode</span><span class="o">*</span> <span class="n">l1</span><span class="p">,</span> <span class="n">ListNode</span><span class="o">*</span> <span class="n">l2</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">ListNode</span> <span class="n">head</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="o">*</span><span class="n">tail</span><span class="p">,</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">carray</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">tail</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">head</span><span class="p">;</span>
        <span class="c1">// loop through each list element
</span>        <span class="k">while</span><span class="p">(</span><span class="n">l1</span> <span class="o">||</span> <span class="n">l2</span><span class="p">){</span>
            <span class="n">p</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ListNode</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
            <span class="c1">// a+b+carray
</span>            <span class="k">if</span><span class="p">(</span><span class="n">l1</span><span class="p">){</span>
                <span class="n">p</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">+=</span> <span class="n">l1</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">;</span>
                <span class="n">l1</span> <span class="o">=</span> <span class="n">l1</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="k">if</span><span class="p">(</span><span class="n">l2</span><span class="p">){</span>
                <span class="n">p</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">+=</span> <span class="n">l2</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">;</span>
                <span class="n">l2</span> <span class="o">=</span> <span class="n">l2</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="n">p</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">+=</span> <span class="n">carray</span><span class="p">;</span>
            <span class="n">carray</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
            <span class="c1">// if sum &gt; 9 than carray
</span>            <span class="k">if</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">&gt;</span> <span class="mi">9</span><span class="p">){</span>
                <span class="n">carray</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">/</span> <span class="mi">10</span><span class="p">;</span>
                <span class="n">p</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">%=</span> <span class="mi">10</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="n">tail</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>
            <span class="n">tail</span> <span class="o">=</span> <span class="n">tail</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="c1">// check if new sum long than l1 and l2
</span>        <span class="k">if</span><span class="p">(</span><span class="n">carray</span><span class="p">){</span>
            <span class="n">p</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ListNode</span><span class="p">(</span><span class="n">carray</span><span class="p">);</span>
            <span class="n">tail</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>
            <span class="n">tail</span> <span class="o">=</span> <span class="n">tail</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="c1">// return
</span>        <span class="k">return</span> <span class="n">head</span><span class="p">.</span><span class="n">next</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span></code></pre></figure>

<p>Check out the <a href="https://leetcode.com/problems/add-two-numbers/description/">Add Two Numbers</a>.</p>


                </div>
                <div class="read-all">
                    <a  href="/2017/09/20/leetcode_alg_2/"><i class="fa fa-newspaper-o"></i>Read All</a>
                </div>
                <hr>
              </li>
            
              <li>
                <h2>
                  <a class="post-link" href="/2017/09/20/leetcode_alg_1/">Leetcode: 1. Two Sum</a>
                </h2>
                <div class="label">
                    <div class="label-card">
                        <i class="fa fa-calendar"></i>2017-09-20
                    </div>
                    <div class="label-card">
                        
                    </div>
                    <div class="label-card">
                        
                    </div>

                    <div class="label-card">
                    


<!-- <span class="point">•</span> -->
<span class="categories">
  <i class="fa fa-th-list"></i>
  
    
        <a href="/category/#leetcode" title="Category: leetcode" rel="category">leetcode</a>&nbsp;
    
        <a href="/category/#algorithm" title="Category: algorithm" rel="category">algorithm</a>
    
  

  <!-- <span class="point">•</span> -->
</span>


                    </div>

                    <div class="label-card">
                    
<!-- <span class="point">•</span> -->
<span class="pageTag">
  <i class="fa fa-tags"></i>
  
    
  

</span>

                    </div>
                </div>
                <div class="excerpt">
                    <h1 id="problem">Problem</h1>
<p>Given an array of integers, return indices of the two numbers such that they add up to a specific target.</p>

<p>You may assume that each input would have exactly one solution, and you may not use the same element twice.</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Example:
Given nums = [2, 7, 11, 15], target = 9,

Because nums[0] + nums[1] = 2 + 7 = 9,
return [0, 1].
</code></pre></div></div>

<h1 id="solution">Solution</h1>

<h3 id="solution-1-the-brute-force">solution 1: The brute force</h3>
<p>The brute force approach is simple. Loop through each element x and find if there is another value that equals to target-x.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">twoSum</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">nums</span><span class="p">,</span> <span class="kt">int</span> <span class="n">target</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">ret</span><span class="p">;</span>
        <span class="c1">//loop through each element x but not last one
</span>        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
        	<span class="c1">// find other value
</span>        	<span class="c1">// a+b and b+a are same combination, so j starts from i+1
</span>      	 	<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">j</span><span class="o">++</span><span class="p">){</span>
                <span class="k">if</span><span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="n">target</span><span class="o">-</span><span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]){</span>
                    <span class="n">ret</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
                    <span class="n">ret</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">j</span><span class="p">);</span>
                    <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span></code></pre></figure>

<h3 id="solution-2-improved-brute-force">solution 2: Improved brute force</h3>
<p>The idea is simple too: sort the vector than perform binary search to find target-x</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="k">struct</span> <span class="n">node</span><span class="p">{</span>
        <span class="kt">int</span> <span class="n">value</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">index</span><span class="p">;</span>
        <span class="kt">bool</span> <span class="k">operator</span><span class="o">&lt;</span><span class="p">(</span><span class="k">const</span> <span class="n">node</span> <span class="o">&amp;</span> <span class="n">other</span><span class="p">)</span> <span class="k">const</span>
        <span class="p">{</span>
            <span class="k">return</span> <span class="n">value</span> <span class="o">&lt;</span> <span class="n">other</span><span class="p">.</span><span class="n">value</span> <span class="p">;</span>
        <span class="p">}</span>
    <span class="p">};</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">twoSum</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">nums</span><span class="p">,</span> <span class="kt">int</span> <span class="n">target</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">ret</span><span class="p">;</span>
        <span class="n">vector</span><span class="o">&lt;</span><span class="n">node</span><span class="o">&gt;</span> <span class="n">nodes</span><span class="p">;</span>
        <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">iterator</span> <span class="n">it</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
        <span class="k">for</span><span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">it</span> <span class="o">=</span> <span class="n">nums</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span> <span class="n">it</span> <span class="o">!=</span> <span class="n">nums</span><span class="p">.</span><span class="n">end</span><span class="p">();</span> <span class="n">it</span><span class="o">++</span><span class="p">,</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
            <span class="n">node</span> <span class="n">n</span> <span class="o">=</span> <span class="p">{.</span><span class="n">value</span> <span class="o">=</span> <span class="o">*</span><span class="n">it</span><span class="p">,</span> <span class="p">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">i</span><span class="p">};</span>
            <span class="n">nodes</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="n">sort</span><span class="p">(</span><span class="n">nodes</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">nodes</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
        <span class="c1">//loop through each element x but not last one
</span>        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nodes</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
        	<span class="c1">// find other value
</span>        	<span class="c1">// a+b and b+a are same combination, so j starts from i+1
</span>            <span class="n">node</span> <span class="n">key</span> <span class="o">=</span> <span class="p">{</span><span class="n">target</span><span class="o">-</span><span class="n">nodes</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">value</span><span class="p">};</span>
            <span class="c1">// binary search if target-x exist
</span>        	<span class="k">if</span> <span class="p">(</span><span class="n">binary_search</span> <span class="p">(</span><span class="n">nodes</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span><span class="o">+</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">nodes</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">key</span><span class="p">)){</span>
                <span class="c1">// binary search not return index, we do it ourselves
</span>	      	 	<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">nodes</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">j</span><span class="o">++</span><span class="p">){</span>
	                <span class="k">if</span><span class="p">(</span><span class="n">nodes</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="n">value</span> <span class="o">==</span> <span class="n">target</span><span class="o">-</span><span class="n">nodes</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">value</span><span class="p">){</span>
	                    <span class="n">ret</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">nodes</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">index</span><span class="p">);</span>
	                    <span class="n">ret</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">nodes</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="n">index</span><span class="p">);</span>
	                    <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	                <span class="p">}</span>
	            <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span></code></pre></figure>

<h3 id="solution-3-hash-table">solution 3: Hash table</h3>
<p>Using hash table to find x and anther target-x</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">twoSum</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">nums</span><span class="p">,</span> <span class="kt">int</span> <span class="n">target</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">unordered_map</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">hash</span><span class="p">;</span>
        <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">ret</span><span class="p">;</span>
        <span class="c1">// loop through each x
</span>        <span class="k">for</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">iterator</span> <span class="n">it</span> <span class="o">=</span> <span class="n">nums</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span> <span class="n">it</span> <span class="o">!=</span> <span class="n">nums</span><span class="p">.</span><span class="n">end</span><span class="p">();</span> <span class="n">it</span><span class="o">++</span><span class="p">){</span>
            <span class="kt">int</span> <span class="n">y</span> <span class="o">=</span> <span class="n">target</span> <span class="o">-</span> <span class="o">*</span><span class="n">it</span><span class="p">;</span>
            <span class="c1">// try to find target-x
</span>            <span class="k">if</span><span class="p">(</span><span class="n">hash</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">y</span><span class="p">)</span> <span class="o">!=</span> <span class="n">hash</span><span class="p">.</span><span class="n">end</span><span class="p">()){</span>
                <span class="n">ret</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">hash</span><span class="p">[</span><span class="n">y</span><span class="p">]);</span>
                <span class="n">ret</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">it</span> <span class="o">-</span> <span class="n">nums</span><span class="p">.</span><span class="n">begin</span><span class="p">());</span>
                <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="c1">// not found, put x to hash
</span>            <span class="n">hash</span><span class="p">[</span><span class="o">*</span><span class="n">it</span><span class="p">]</span> <span class="o">=</span> <span class="n">it</span> <span class="o">-</span> <span class="n">nums</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">};</span></code></pre></figure>

<p>Check out the <a href="https://leetcode.com/problems/two-sum/description/">Two sum</a>.</p>


                </div>
                <div class="read-all">
                    <a  href="/2017/09/20/leetcode_alg_1/"><i class="fa fa-newspaper-o"></i>Read All</a>
                </div>
                <hr>
              </li>
            
        </ul>



        <!-- Pagination links -->
        <div class="pagination">
          
            <span class="previous disable"><i class="fa fa-angle-double-left"></i></span>
            <span class="previous disable"><i class="fa fa-angle-left"></i></span>
          
          <span class="page_number ">1/1</span>
          
            <span class="next disable"><i class="fa fa-angle-right"></i></span>
            <span class="next disable"><i class="fa fa-angle-double-right"></i></span>
          
        </div>
    </div>
    <!-- <button class="anchor"><i class="fa fa-anchor"></i></button> -->
    <div class="right">
        <div class="wrap">
            <div class="side">
                <div>
                    <i class="fa fa-pencil-square-o" aria-hidden="true"></i>
                    Recent Posts
                </div>
                <ul class="content-ul" recent>
                    
                        <li><a href="/2017/09/22/javascritp_closure/">Javascript closure</a></li>
                    
                        <li><a href="/2017/09/20/leetcode_alg_2/">Leetcode: 2. Add Two Numbers</a></li>
                    
                        <li><a href="/2017/09/20/leetcode_alg_1/">Leetcode: 1. Two Sum</a></li>
                    
                </ul>
            </div>

            <!-- Content -->
            <div class="side ">
                <div>
                    <i class="fa fa-th-list"></i>
                    Categories
                </div>
                <ul class="content-ul" cate>
                    
                    <li>
                        <a href="/category/#leetcode" class="categories-list-item" cate="leetcode">
                            <span class="name">
                                leetcode
                            </span>
                            <span class="badge">2</span>
                        </a>
                    </li>
                    
                    <li>
                        <a href="/category/#algorithm" class="categories-list-item" cate="algorithm">
                            <span class="name">
                                algorithm
                            </span>
                            <span class="badge">2</span>
                        </a>
                    </li>
                    
                    <li>
                        <a href="/category/#javascript" class="categories-list-item" cate="javascript">
                            <span class="name">
                                javascript
                            </span>
                            <span class="badge">1</span>
                        </a>
                    </li>
                    
                </ul>
            </div>
            <!-- 其他div框放到这里 -->
            <div class="side">
                <div>
                    <i class="fa fa-tags"></i>
                    Tags
                </div>
                <div class="tags-cloud">
                    
                    
                    
                    
                    

                    
                </div>
            </div>

            <!-- <div class="side">
                <div>
                    <i class="fa fa-external-link"></i>
                    Links
                </div>
                <ul  class="content-ul">

                </ul>
            </div> -->
        </div>
    </div>
</div>
<!-- <script src="/js/scroll.min.js " charset="utf-8"></script> -->
<!-- <script src="/js/pageContent.js " charset="utf-8"></script> -->


    <footer class="site-footer">


    <div class="wrapper">

        <p class="description">
             本站记录我软件之旅的沿途风景！ 
        </p>
        <p class="contact">
            Contact me at: 
            <a href="https://github.com/hanjianqiao"><i class="fa fa-github" aria-hidden="true"></i></a>  
            <a href="mailto:hanjianqiao@gmail.com"><i class="fa fa-envelope-o" aria-hidden="true"></i></a>   
            <a href="https://www.zhihu.com/people/hanjianqiao"><i class="iconfont">&#xe829;</i></a>   
        </p>
        <!--p>
            本站总访问量<span id="busuanzi_value_site_pv"></span>次，本站访客数<span id="busuanzi_value_site_uv"></span>人次，本文总阅读量<span id="busuanzi_value_page_pv"></span>次
        </p -->
        <p class="power">
            <span>
                Site powered by <a href="https://jekyllrb.com/">Jekyll</a> & <a href="https://pages.github.com/">Github Pages</a>.
            </span>
            <span>
                Theme designed by <a href="https://github.com/Gaohaoyang">HyG</a>.
            </span>
        </p>
    </div>
</footer>
<script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

    <div class="back-to-top">
    <a href="#top" class="scroll">
        <i class="fa fa-arrow-up" aria-hidden="true"></i>
    </a>
</div>

    <script src=" /js/main.js " charset="utf-8"></script>
    <script src=" /js/scroll.min.js " charset="utf-8"></script>
  </body>

</html>
